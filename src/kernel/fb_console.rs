use core::ptr::{read_volatile, write_volatile};
use crate::multiboot_parser::Framebuffer;

/// 8x8 basic ASCII font (characters 0x20..0x7F).
/// Source: font8x8_basic (public-domain / permissive). Each entry is 8 rows, LSB = left pixel.
/// The array length is 96 (0x7F - 0x20).
const FONT8X8_BASIC: [[u8; 8]; 96] = [
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00], // 0x20 ' '
    [0x18,0x3c,0x3c,0x18,0x18,0x00,0x18,0x00], // 0x21 '!'
    [0x36,0x36,0x24,0x00,0x00,0x00,0x00,0x00], // 0x22 '"'
    [0x36,0x36,0x7f,0x36,0x7f,0x36,0x36,0x00], // 0x23 '#'
    [0x0c,0x3e,0x03,0x1e,0x30,0x1f,0x0c,0x00], // 0x24 '$'
    [0x00,0x63,0x33,0x18,0x0c,0x66,0x63,0x00], // 0x25 '%'
    [0x1c,0x36,0x1c,0x6e,0x3b,0x33,0x6e,0x00], // 0x26 '&'
    [0x06,0x06,0x04,0x00,0x00,0x00,0x00,0x00], // 0x27 '''
    [0x18,0x0c,0x06,0x06,0x06,0x0c,0x18,0x00], // 0x28 '('
    [0x06,0x0c,0x18,0x18,0x18,0x0c,0x06,0x00], // 0x29 ')'
    [0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00], // 0x2A '*'
    [0x00,0x0c,0x0c,0x3f,0x0c,0x0c,0x00,0x00], // 0x2B '+'
    [0x00,0x00,0x00,0x00,0x00,0x0c,0x0c,0x06], // 0x2C ','
    [0x00,0x00,0x00,0x3f,0x00,0x00,0x00,0x00], // 0x2D '-'
    [0x00,0x00,0x00,0x00,0x00,0x0c,0x0c,0x00], // 0x2E '.'
    [0x60,0x30,0x18,0x0c,0x06,0x03,0x01,0x00], // 0x2F '/'
    [0x3e,0x63,0x73,0x7b,0x6f,0x67,0x3e,0x00], // 0x30 '0'
    [0x0c,0x0e,0x0c,0x0c,0x0c,0x0c,0x3f,0x00], // 0x31 '1'
    [0x1e,0x33,0x30,0x1c,0x06,0x33,0x3f,0x00], // 0x32 '2'
    [0x1e,0x33,0x30,0x1c,0x30,0x33,0x1e,0x00], // 0x33 '3'
    [0x38,0x3c,0x36,0x33,0x7f,0x30,0x78,0x00], // 0x34 '4'
    [0x3f,0x03,0x1f,0x30,0x30,0x33,0x1e,0x00], // 0x35 '5'
    [0x1c,0x06,0x03,0x1f,0x33,0x33,0x1e,0x00], // 0x36 '6'
    [0x3f,0x33,0x30,0x18,0x0c,0x0c,0x0c,0x00], // 0x37 '7'
    [0x1e,0x33,0x33,0x1e,0x33,0x33,0x1e,0x00], // 0x38 '8'
    [0x1e,0x33,0x33,0x3e,0x30,0x18,0x0f,0x00], // 0x39 '9'
    [0x00,0x0c,0x0c,0x00,0x00,0x0c,0x0c,0x00], // 0x3A ':'
    [0x00,0x0c,0x0c,0x00,0x00,0x0c,0x0c,0x06], // 0x3B ';'
    [0x18,0x0c,0x06,0x03,0x06,0x0c,0x18,0x00], // 0x3C '<'
    [0x00,0x00,0x3f,0x00,0x00,0x3f,0x00,0x00], // 0x3D '='
    [0x06,0x0c,0x18,0x30,0x18,0x0c,0x06,0x00], // 0x3E '>'
    [0x1e,0x33,0x30,0x18,0x0c,0x00,0x0c,0x00], // 0x3F '?'
    [0x3e,0x63,0x6f,0x6f,0x6f,0x03,0x1e,0x00], // 0x40 '@'
    [0x0c,0x1e,0x33,0x33,0x3f,0x33,0x33,0x00], // 0x41 'A'
    [0x3f,0x66,0x66,0x3e,0x66,0x66,0x3f,0x00], // 0x42 'B'
    [0x3c,0x66,0x03,0x03,0x03,0x66,0x3c,0x00], // 0x43 'C'
    [0x1f,0x36,0x66,0x66,0x66,0x36,0x1f,0x00], // 0x44 'D'
    [0x7f,0x46,0x16,0x1e,0x16,0x46,0x7f,0x00], // 0x45 'E'
    [0x7f,0x46,0x16,0x1e,0x16,0x06,0x0f,0x00], // 0x46 'F'
    [0x3c,0x66,0x03,0x03,0x73,0x66,0x7c,0x00], // 0x47 'G'
    [0x33,0x33,0x33,0x3f,0x33,0x33,0x33,0x00], // 0x48 'H'
    [0x1e,0x0c,0x0c,0x0c,0x0c,0x0c,0x1e,0x00], // 0x49 'I'
    [0x78,0x30,0x30,0x30,0x33,0x33,0x1e,0x00], // 0x4A 'J'
    [0x67,0x66,0x36,0x1e,0x36,0x66,0x67,0x00], // 0x4B 'K'
    [0x0f,0x06,0x06,0x06,0x46,0x66,0x7f,0x00], // 0x4C 'L'
    [0x63,0x77,0x7f,0x7f,0x6b,0x63,0x63,0x00], // 0x4D 'M'
    [0x63,0x67,0x6f,0x7b,0x73,0x63,0x63,0x00], // 0x4E 'N'
    [0x1c,0x36,0x63,0x63,0x63,0x36,0x1c,0x00], // 0x4F 'O'
    [0x3f,0x66,0x66,0x3f,0x06,0x06,0x0f,0x00], // 0x50 'P'
    [0x1e,0x33,0x33,0x33,0x3b,0x1e,0x38,0x00], // 0x51 'Q'
    [0x3f,0x66,0x66,0x3f,0x36,0x66,0x67,0x00], // 0x52 'R'
    [0x1e,0x33,0x07,0x0e,0x38,0x33,0x1e,0x00], // 0x53 'S'
    [0x3f,0x2d,0x0c,0x0c,0x0c,0x0c,0x1e,0x00], // 0x54 'T'
    [0x33,0x33,0x33,0x33,0x33,0x33,0x3f,0x00], // 0x55 'U'
    [0x33,0x33,0x33,0x33,0x33,0x1e,0x0c,0x00], // 0x56 'V'
    [0x63,0x63,0x63,0x6b,0x7f,0x77,0x63,0x00], // 0x57 'W'
    [0x63,0x63,0x36,0x1c,0x1c,0x36,0x63,0x00], // 0x58 'X'
    [0x33,0x33,0x33,0x1e,0x0c,0x0c,0x1e,0x00], // 0x59 'Y'
    [0x7f,0x63,0x31,0x18,0x0c,0x46,0x7f,0x00], // 0x5A 'Z'
    [0x1e,0x06,0x06,0x06,0x06,0x06,0x1e,0x00], // 0x5B '['
    [0x03,0x06,0x0c,0x18,0x30,0x60,0x40,0x00], // 0x5C '\'
    [0x1e,0x18,0x18,0x18,0x18,0x18,0x1e,0x00], // 0x5D ']'
    [0x08,0x1c,0x36,0x63,0x00,0x00,0x00,0x00], // 0x5E '^'
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff], // 0x5F '_'
    [0x0c,0x0c,0x06,0x00,0x00,0x00,0x00,0x00], // 0x60 '`'
    [0x00,0x00,0x1e,0x30,0x3e,0x33,0x6e,0x00], // 0x61 'a'
    [0x07,0x06,0x06,0x1e,0x36,0x36,0x1b,0x00], // 0x62 'b'
    [0x00,0x00,0x1e,0x33,0x03,0x33,0x1e,0x00], // 0x63 'c'
    [0x38,0x30,0x30,0x3e,0x33,0x33,0x6e,0x00], // 0x64 'd'
    [0x00,0x00,0x1e,0x33,0x3f,0x03,0x1e,0x00], // 0x65 'e'
    [0x1c,0x36,0x06,0x0f,0x06,0x06,0x0f,0x00], // 0x66 'f'
    [0x00,0x00,0x6e,0x33,0x33,0x3e,0x30,0x1f], // 0x67 'g'
    [0x07,0x06,0x36,0x6e,0x66,0x66,0x67,0x00], // 0x68 'h'
    [0x0c,0x00,0x0e,0x0c,0x0c,0x0c,0x1e,0x00], // 0x69 'i'
    [0x30,0x00,0x38,0x30,0x30,0x33,0x33,0x1e], // 0x6A 'j'
    [0x07,0x06,0x66,0x36,0x1e,0x36,0x67,0x00], // 0x6B 'k'
    [0x0e,0x0c,0x0c,0x0c,0x0c,0x0c,0x1e,0x00], // 0x6C 'l'
    [0x00,0x00,0x33,0x7f,0x7f,0x6b,0x63,0x00], // 0x6D 'm'
    [0x00,0x00,0x1f,0x33,0x33,0x33,0x33,0x00], // 0x6E 'n'
    [0x00,0x00,0x1e,0x33,0x33,0x33,0x1e,0x00], // 0x6F 'o'
    [0x00,0x00,0x1b,0x36,0x36,0x1e,0x06,0x0f], // 0x70 'p'
    [0x00,0x00,0x6e,0x33,0x33,0x3e,0x30,0x78], // 0x71 'q'
    [0x00,0x00,0x1b,0x36,0x06,0x06,0x0f,0x00], // 0x72 'r'
    [0x00,0x00,0x3e,0x03,0x1e,0x30,0x1f,0x00], // 0x73 's'
    [0x08,0x0c,0x3e,0x0c,0x0c,0x2c,0x18,0x00], // 0x74 't'
    [0x00,0x00,0x33,0x33,0x33,0x33,0x6e,0x00], // 0x75 'u'
    [0x00,0x00,0x33,0x33,0x33,0x1e,0x0c,0x00], // 0x76 'v'
    [0x00,0x00,0x63,0x6b,0x7f,0x36,0x36,0x00], // 0x77 'w'
    [0x00,0x00,0x63,0x36,0x1c,0x36,0x63,0x00], // 0x78 'x'
    [0x00,0x00,0x33,0x33,0x33,0x3e,0x30,0x1f], // 0x79 'y'
    [0x00,0x00,0x3f,0x19,0x0c,0x26,0x3f,0x00], // 0x7A 'z'
    [0x38,0x0c,0x0c,0x07,0x0c,0x0c,0x38,0x00], // 0x7B '{'
    [0x0c,0x0c,0x0c,0x00,0x0c,0x0c,0x0c,0x00], // 0x7C '|'
    [0x07,0x0c,0x0c,0x38,0x0c,0x0c,0x07,0x00], // 0x7D '}'
    [0x6e,0x3b,0x00,0x00,0x00,0x00,0x00,0x00], // 0x7E '~'
    [0x00,0x10,0x38,0x6c,0xc6,0xfe,0x00,0x00], // 0x7F DEL (not printable but included)
];

/// Console that renders text with the 8x8 font on a Framebuffer.
pub struct Console {
    fb: Framebuffer,
    cursor_col: usize,
    cursor_row: usize,
    cols: usize,
    rows: usize,
    fg_color: u32,
    bg_color: u32,
    tab_size: usize,
}

impl Console {
    /// Create a new console bound to a Framebuffer value.
    /// Safety: framebuffer memory must be writable (mapped) for the lifetime of this Console.
    pub unsafe fn new(fb: Framebuffer, fg_color: u32, bg_color: u32) -> Self {
        let cols = fb.width / 8;
        let rows = fb.height / 8;
        Console {
            fb,
            cursor_col: 0,
            cursor_row: 0,
            cols: cols.max(1),
            rows: rows.max(1),
            fg_color,
            bg_color,
            tab_size: 4,
        }
    }

    /// Clear the entire screen to bg color.
    pub unsafe fn clear(&mut self) {
        // use framebuffer fast fill if available
        self.fb.fill_rect(0, 0, self.fb.width, self.fb.height, self.bg_color);
        self.cursor_col = 0;
        self.cursor_row = 0;
    }

    /// Handle newline (move to next row, scroll if needed).
    unsafe fn newline(&mut self) {
        self.cursor_col = 0;
        self.cursor_row += 1;
        if self.cursor_row >= self.rows {
            self.scroll_up(1);
            self.cursor_row = self.rows - 1;
        }
    }

    /// Scroll the framebuffer up by `lines` character-rows (each 8 pixels tall).
    /// This moves displayed pixels upward and clears the bottom lines.
    unsafe fn scroll_up(&mut self, lines: usize) {
        if lines == 0 { return; }
        let char_h = 8;
        let shift_bytes = lines * char_h * self.fb.pitch;
        let total_bytes = self.fb.pitch * self.fb.height;

        let src_start = (shift_bytes) as isize;
        let dst_start = 0isize;
        let copy_bytes = total_bytes.saturating_sub(shift_bytes);

        // raw pointer to framebuffer base
        let vbase = self.fb.phys_addr as *mut u8;

        // memmove: copy from vbase+src to vbase (forward copy is safe because src > dst)
        // copy using u8 volatile reads/writes
        for i in 0..copy_bytes {
            let val = read_volatile(vbase.offset(src_start + i as isize));
            write_volatile(vbase.offset(dst_start + i as isize), val);
        }

        // clear bottom region (the newly freed bytes at end)
        let clear_start = copy_bytes;
        let clear_len = total_bytes.saturating_sub(copy_bytes);
        for i in 0..clear_len {
            write_volatile(vbase.offset((clear_start + i) as isize), 0u8);
        }
    }

    /// Put a single glyph at current cursor position, advance cursor.
    /// glyph drawn with fg_color on bg_color.
    unsafe fn draw_glyph_at_cell(&mut self, glyph: &[u8;8], col: usize, row: usize) {
        let x0 = col * 8;
        let y0 = row * 8;

        // draw 8x8
        for (ry, byte) in glyph.iter().enumerate() {
            let y = y0 + ry;
            for bit in 0..8 {
                let x = x0 + bit;
                // LSB is left pixel in our font table; adjust if necessary
                let mask = 1u8 << bit;
                let pixel_on = (byte & mask) != 0;
                if pixel_on {
                    self.fb.put_pixel(x, y, self.fg_color);
                } else {
                    self.fb.put_pixel(x, y, self.bg_color);
                }
            }
        }
    }

    /// Put a single character (ASCII). Control characters: '\n','\r','\t' handled.
    /// Printable chars in range 0x20..0x7F are drawn using the font.
    pub unsafe fn put_char(&mut self, ch: u8) {
        match ch {
            b'\n' => { self.newline(); }
            b'\r' => { self.cursor_col = 0; }
            b'\t' => {
                let next = (self.cursor_col + self.tab_size).min(self.cols - 1);
                self.cursor_col = next;
            }
            c @ 0x20..=0x7F => {
                let idx = (c - 0x20) as usize;
                let glyph = &FONT8X8_BASIC[idx];
                self.draw_glyph_at_cell(glyph, self.cursor_col, self.cursor_row);
                self.cursor_col += 1;
                if self.cursor_col >= self.cols {
                    self.newline();
                }
            }
            _ => {
                // unsupported -> draw a blank or replacement char
                let glyph = &FONT8X8_BASIC[0]; // space
                self.draw_glyph_at_cell(glyph, self.cursor_col, self.cursor_row);
                self.cursor_col += 1;
                if self.cursor_col >= self.cols {
                    self.newline();
                }
            }
        }
    }

    /// Put a &str (utf-8) â€” non-ascii bytes are skipped.
    pub unsafe fn put_str(&mut self, s: &str) {
        for &b in s.as_bytes() {
            // Only handle ASCII bytes; skip multi-byte sequences for now
            self.put_char(b);
        }
    }

    /// Set foreground and background colors for subsequent text.
    pub fn set_colors(&mut self, fg: u32, bg: u32) {
        self.fg_color = fg;
        self.bg_color = bg;
    }

    /// Move the cursor to an absolute column/row (clamped).
    pub fn set_cursor(&mut self, col: usize, row: usize) {
        self.cursor_col = col.min(self.cols - 1);
        self.cursor_row = row.min(self.rows - 1);
    }
}
